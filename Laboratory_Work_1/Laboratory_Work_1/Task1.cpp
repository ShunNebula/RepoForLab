int Gcd(int a, int b)
{
	if (b == 0)
		{
		return a;
		}
	return Gcd(b, a % b);
	}
/* 
T(n) = O(log(min(a, b)))
M(n) = O(log(min(a, b)))*//*Функция GCD использует рекурсивный вызов, где в каждом шаге меньшее число заменяется на остаток от деления.Наихудший случай: когда a и b являются последовательными числами Фибоначчи.Последовательность Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...Таким образом, время выполнения алгоритма растет логарифмически по отношению к меньшему из двух чисел.Поскольку алгоритм использует рекурсию, для хранения временных данных требуется стековая память.
Количество рекурсивных вызовов также ограничено log(min(a, b)), поэтому потребление памяти также логарифмически растет.*/